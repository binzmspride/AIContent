import type { Express } from "express";
import { createServer, type Server } from "http";
import https from 'https';
import { storage } from "./storage";
import { setupAuth } from "./auth";
import * as schema from "@shared/schema";
import { db } from "../db";
import { sql, eq } from "drizzle-orm";
import { ApiResponse, GenerateContentRequest, GenerateContentResponse } from "@shared/types";
import { systemSettings } from "@shared/schema";
import { randomBytes, scrypt, timingSafeEqual } from "crypto";
import { promisify } from "util";

// Interface để thêm trường vào content request
interface ExtendedContentRequest extends GenerateContentRequest {
  articleId?: number;
  userId?: number;
  username?: string;
  timestamp?: string;
}

export async function registerRoutes(app: Express): Promise<Server> {
  // Set up authentication routes
  setupAuth(app);

  // API routes
  const httpServer = createServer(app);

  // ========== Plans API ==========
  // Get all plans
  app.get('/api/plans', async (req, res) => {
    try {
      const type = req.query.type as schema.PlanType | undefined;
      const plans = await storage.getPlans(type);
      res.json({ success: true, data: plans });
    } catch (error) {
      console.error('Error fetching plans:', error);
      res.status(500).json({ success: false, error: 'Failed to fetch plans' });
    }
  });

  // ========== Dashboard API ==========
  // Get dashboard stats
  app.get('/api/dashboard/stats', async (req, res) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ success: false, error: 'Not authenticated' });
      }

      const userId = req.user.id;
      
      // Get user's credit balance
      const creditBalance = await storage.getUserCredits(userId);
      
      // Get user's articles
      const { articles, total: totalArticles } = await storage.getArticlesByUser(userId, 1, 0);
      
      // Get user's connections
      const connections = await storage.getConnections(userId);
      
      // Get user's storage plan
      const userPlans = await storage.getUserPlans(userId);
      const storagePlan = userPlans.find(up => up.plan.type === 'storage' && up.isActive);
      
      // Calculate monthly change (mock data for now)
      const monthlyChange = 0.12; // 12% increase
      
      // Prepare connections status
      const connectionsStatus = {
        wordpress: connections.some(c => c.type === 'wordpress' && c.isActive),
        facebook: connections.some(c => c.type === 'facebook' && c.isActive),
        tiktok: connections.some(c => c.type === 'tiktok' && c.isActive),
        twitter: connections.some(c => c.type === 'twitter' && c.isActive),
      };
      
      // Prepare storage stats
      const storageStats = storagePlan 
        ? {
            current: storagePlan.usedStorage,
            total: storagePlan.plan.value,
            percentage: (storagePlan.usedStorage / storagePlan.plan.value) * 100
          }
        : {
            current: 0,
            total: 0,
            percentage: 0
          };
      
      res.json({
        success: true,
        data: {
          creditBalance,
          articlesCreated: {
            total: totalArticles,
            monthlyChange
          },
          storageUsed: storageStats,
          connections: connectionsStatus
        }
      });
    } catch (error) {
      console.error('Error fetching dashboard stats:', error);
      res.status(500).json({ success: false, error: 'Failed to fetch dashboard stats' });
    }
  });

  // Get user's articles
  app.get('/api/dashboard/articles', async (req, res) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ success: false, error: 'Not authenticated' });
      }

      const userId = req.user.id;
      const page = parseInt(req.query.page as string || '1');
      const limit = parseInt(req.query.limit as string || '10');
      
      const { articles, total } = await storage.getArticlesByUser(userId, page, limit);
      
      res.json({
        success: true,
        data: {
          articles,
          pagination: {
            page,
            limit,
            total,
            totalPages: Math.ceil(total / limit)
          }
        }
      });
    } catch (error) {
      console.error('Error fetching user articles:', error);
      res.status(500).json({ success: false, error: 'Failed to fetch articles' });
    }
  });

  // Get article by id
  app.get('/api/dashboard/articles/:id', async (req, res) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ success: false, error: 'Not authenticated' });
      }
      
      const userId = req.user.id;
      const articleId = parseInt(req.params.id, 10);
      
      if (isNaN(articleId)) {
        return res.status(400).json({ success: false, error: 'Invalid article ID' });
      }
      
      const article = await storage.getArticleById(articleId);
      
      if (!article) {
        return res.status(404).json({ success: false, error: 'Article not found' });
      }
      
      // Kiểm tra quyền sở hữu bài viết
      if (article.userId !== userId && req.user.role !== 'admin') {
        return res.status(403).json({ success: false, error: 'You do not have permission to access this article' });
      }
      
      res.json({ success: true, data: article });
    } catch (error) {
      console.error('Error fetching article details:', error);
      res.status(500).json({ success: false, error: 'Failed to fetch article details' });
    }
  });

  // Update article by id
  app.patch('/api/dashboard/articles/:id', async (req, res) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ success: false, error: 'Not authenticated' });
      }
      
      const userId = req.user.id;
      const articleId = parseInt(req.params.id, 10);
      
      if (isNaN(articleId)) {
        return res.status(400).json({ success: false, error: 'Invalid article ID' });
      }
      
      const article = await storage.getArticleById(articleId);
      
      if (!article) {
        return res.status(404).json({ success: false, error: 'Article not found' });
      }
      
      // Kiểm tra quyền sở hữu bài viết
      if (article.userId !== userId && req.user.role !== 'admin') {
        return res.status(403).json({ success: false, error: 'You do not have permission to update this article' });
      }
      
      // Lấy dữ liệu cập nhật
      const { title, content, keywords, status } = req.body;
      
      // Cập nhật bài viết
      const updatedArticle = await storage.updateArticle(articleId, {
        title,
        content,
        keywords,
        status,
      });
      
      res.json({ success: true, data: updatedArticle });
    } catch (error) {
      console.error('Error updating article:', error);
      res.status(500).json({ success: false, error: 'Failed to update article' });
    }
  });

  // Create article
  app.post('/api/dashboard/articles', async (req, res) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ success: false, error: 'Not authenticated' });
      }

      const userId = req.user.id;
      const { title, content, keywords, creditsUsed = 1 } = req.body;
      
      // Check if user has enough credits
      const userCredits = await storage.getUserCredits(userId);
      if (userCredits < creditsUsed) {
        return res.status(400).json({ success: false, error: 'Insufficient credits' });
      }
      
      // Create article
      const article = await storage.createArticle({
        userId,
        title,
        content,
        keywords,
        creditsUsed,
        status: 'draft'
      });
      
      // Subtract credits
      await storage.subtractUserCredits(userId, creditsUsed, `Created article: ${title}`);
      
      res.status(201).json({ success: true, data: article });
    } catch (error) {
      console.error('Error creating article:', error);
      res.status(500).json({ success: false, error: 'Failed to create article' });
    }
  });

  // Generate content API - tạo nội dung trong ứng dụng
  app.post('/api/dashboard/generate-content', async (req, res) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ success: false, error: 'Not authenticated' });
      }

      const userId = req.user.id;
      const contentRequest = req.body as GenerateContentRequest;
      
      // Determine credits needed based on content length
      let creditsNeeded = 1;
      if (contentRequest.length === 'long') creditsNeeded = 2;
      if (contentRequest.length === 'extra_long') creditsNeeded = 3;
      
      // Check if user has enough credits
      const userCredits = await storage.getUserCredits(userId);
      if (userCredits < creditsNeeded) {
        return res.status(400).json({ 
          success: false, 
          error: 'Insufficient credits' 
        });
      }
      
      // Get webhook URL from system settings
      const webhookSettingRes = await db.query.systemSettings.findFirst({
        where: eq(systemSettings.key, 'notificationWebhookUrl')
      });
      
      const webhookUrl = webhookSettingRes?.value;
      console.log('=== GENERATE CONTENT API CALLED ===');
      console.log('Webhook URL from database:', webhookUrl);
      
      // Xóa chế độ offline mode theo yêu cầu
      
      if (!webhookUrl) {
        return res.status(404).json({ 
          success: false, 
          error: 'Webhook URL not configured'
        });
      }
      
      // Lấy webhook secret
      const webhookSecretRes = await db.query.systemSettings.findFirst({
        where: eq(systemSettings.key, 'webhook_secret')
      });
      const webhookSecret = webhookSecretRes?.value;
      console.log('Webhook Secret from database:', webhookSecret ? '(exists)' : '(missing)');
      
      // Gửi request đến webhook
      console.log('Sending content request to webhook:', webhookUrl);
      
      // Thêm userId và username vào yêu cầu
      const extendedRequest: ExtendedContentRequest = {
        ...contentRequest,
        userId,
        username: req.user.username,
        timestamp: new Date().toISOString()
      };
      
      // Ghi log yêu cầu gửi đến webhook
      console.log('Webhook payload:', JSON.stringify(extendedRequest, null, 2));
      
      // Tạo header cho request
      const headers: HeadersInit = {
        'Content-Type': 'application/json'
      };
      
      // Thêm header X-Webhook-Secret nếu có
      if (webhookSecret) {
        headers['X-Webhook-Secret'] = webhookSecret;
      }
      
      // ===== GIẢI PHÁP MỚI CHO WEBHOOK TIMEOUT =====
      // 
      // Thay vì chờ đợi webhook hoàn thành (có thể mất hơn 1 phút - bị timeout),
      // chúng ta sẽ:
      // 1. Tạo bài viết nháp ngay lập tức
      // 2. Trả về bài viết nháp cho người dùng
      // 3. Khởi chạy webhook trong background
      // 4. Cập nhật bài viết khi webhook hoàn thành
      
      // Tạo bài viết nháp trong cơ sở dữ liệu
      const draftArticle: schema.InsertArticle = {
        userId,
        title: "Đang xử lý",
        content: "<p>Đang xử lý yêu cầu tạo nội dung...</p>",
        keywords: contentRequest.keywords, 
        status: "draft",
        publishedUrl: null,
        creditsUsed: creditsNeeded
      };
      
      try {
        // Lưu bài viết nháp trước khi gửi webhook
        const savedDraft = await storage.createArticle(draftArticle);
        console.log('Draft article saved with ID:', savedDraft.id);
        
        // Trừ credits người dùng
        await storage.subtractUserCredits(userId, creditsNeeded, "Tạo nội dung bài viết");
        
        // Thêm articleId vào request webhook để cập nhật bài viết sau khi webhook hoàn thành
        extendedRequest.articleId = savedDraft.id;
        
        // Gửi webhook trong một tiến trình riêng không chờ đợi
        console.log('Starting webhook request in background at:', new Date().toISOString());
        
        // Khởi động request webhook mà không chờ đợi kết quả
        fetch(webhookUrl, {
          method: 'POST',
          headers,
          body: JSON.stringify(extendedRequest)
        })
        .then(async (webhookResponse) => {
          console.log('Webhook response received at:', new Date().toISOString(), 'Status:', webhookResponse.status);
          
          if (!webhookResponse.ok) {
            console.log(`Webhook error status: ${webhookResponse.status}`);
            return;
          }
          
          try {
            // Xử lý phản hồi webhook và cập nhật bài viết trong cơ sở dữ liệu
            const responseText = await webhookResponse.text();
            let webhookData;
            
            try {
              webhookData = JSON.parse(responseText);
              console.log('Webhook response content received successfully');
            } catch (parseError) {
              console.error('Failed to parse webhook response as JSON:', parseError);
              return;
            }
            
            if (savedDraft.id && webhookData) {
              // Cập nhật bài viết với nội dung từ webhook
              const updatedArticle = {
                title: webhookData[0]?.aiTitle || webhookData?.aiTitle || "Bài viết mới",
                content: webhookData[0]?.content || webhookData?.content || "<p>Không có nội dung</p>",
                updatedAt: new Date()
              };
              
              await storage.updateArticle(savedDraft.id, updatedArticle);
              console.log('Article updated with content from webhook, article ID:', savedDraft.id);
            }
          } catch (error) {
            console.error('Error processing webhook response:', error);
          }
        })
        .catch(error => {
          console.error('Webhook request failed:', error);
        });
        
        // Trả về bài viết nháp cho người dùng ngay lập tức
        return res.status(200).json({
          success: true,
          data: [{
            title: "Đang xử lý", 
            content: "<p>Đang xử lý yêu cầu tạo nội dung...</p>", 
            articleId: savedDraft.id,
            keywords: contentRequest.keywords.split(',').map(k => k.trim()),
            creditsUsed: creditsNeeded
          }]
        });
      } catch (error) {
        console.error('Error creating draft article:', error);
        
        return res.status(500).json({
          success: false,
          error: 'Không thể tạo bài viết. Vui lòng thử lại sau.'
        });
      }
    } catch (error) {
      console.error('Error in generate-content endpoint:', error);
      res.status(500).json({ 
        success: false, 
        error: 'An error occurred while processing your request'
      });
    }
  });

  // Published articles
  app.get('/api/dashboard/published', async (req, res) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ success: false, error: 'Not authenticated' });
      }

      const userId = req.user.id;
      const page = parseInt(req.query.page as string || '1');
      const limit = parseInt(req.query.limit as string || '10');
      
      const { articles, total } = await storage.getArticlesByUser(userId, page, limit, 'published');
      
      res.json({
        success: true,
        data: {
          articles,
          pagination: {
            page,
            limit,
            total,
            totalPages: Math.ceil(total / limit)
          }
        }
      });
    } catch (error) {
      console.error('Error fetching published articles:', error);
      res.status(500).json({ success: false, error: 'Failed to fetch published articles' });
    }
  });

  // Publish article
  app.post('/api/dashboard/articles/:id/publish', async (req, res) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ success: false, error: 'Not authenticated' });
      }
      
      const userId = req.user.id;
      const articleId = parseInt(req.params.id, 10);
      
      if (isNaN(articleId)) {
        return res.status(400).json({ success: false, error: 'Invalid article ID' });
      }
      
      const article = await storage.getArticleById(articleId);
      
      if (!article) {
        return res.status(404).json({ success: false, error: 'Article not found' });
      }
      
      // Kiểm tra quyền sở hữu bài viết
      if (article.userId !== userId && req.user.role !== 'admin') {
        return res.status(403).json({ success: false, error: 'You do not have permission to publish this article' });
      }
      
      // Cập nhật trạng thái
      const publishedArticle = await storage.updateArticle(articleId, {
        status: 'published',
        publishedAt: new Date()
      });
      
      res.json({ success: true, data: publishedArticle });
    } catch (error) {
      console.error('Error publishing article:', error);
      res.status(500).json({ success: false, error: 'Failed to publish article' });
    }
  });

  // Trash article
  app.post('/api/dashboard/articles/:id/trash', async (req, res) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ success: false, error: 'Not authenticated' });
      }
      
      const userId = req.user.id;
      const articleId = parseInt(req.params.id, 10);
      
      if (isNaN(articleId)) {
        return res.status(400).json({ success: false, error: 'Invalid article ID' });
      }
      
      const article = await storage.getArticleById(articleId);
      
      if (!article) {
        return res.status(404).json({ success: false, error: 'Article not found' });
      }
      
      // Kiểm tra quyền sở hữu bài viết
      if (article.userId !== userId && req.user.role !== 'admin') {
        return res.status(403).json({ success: false, error: 'You do not have permission to trash this article' });
      }
      
      // Cập nhật trạng thái
      const trashedArticle = await storage.updateArticle(articleId, {
        status: 'trash',
        trashedAt: new Date()
      });
      
      res.json({ success: true, data: trashedArticle });
    } catch (error) {
      console.error('Error trashing article:', error);
      res.status(500).json({ success: false, error: 'Failed to trash article' });
    }
  });

  // Delete article permanently
  app.delete('/api/dashboard/articles/:id', async (req, res) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ success: false, error: 'Not authenticated' });
      }
      
      const userId = req.user.id;
      const articleId = parseInt(req.params.id, 10);
      
      if (isNaN(articleId)) {
        return res.status(400).json({ success: false, error: 'Invalid article ID' });
      }
      
      const article = await storage.getArticleById(articleId);
      
      if (!article) {
        return res.status(404).json({ success: false, error: 'Article not found' });
      }
      
      // Kiểm tra quyền sở hữu bài viết
      if (article.userId !== userId && req.user.role !== 'admin') {
        return res.status(403).json({ success: false, error: 'You do not have permission to delete this article' });
      }
      
      // Xóa vĩnh viễn bài viết
      const success = await storage.deleteArticle(articleId);
      
      if (success) {
        res.json({ success: true, message: 'Article deleted successfully' });
      } else {
        res.status(500).json({ success: false, error: 'Failed to delete article' });
      }
    } catch (error) {
      console.error('Error deleting article:', error);
      res.status(500).json({ success: false, error: 'Failed to delete article' });
    }
  });

  // Restore article from trash
  app.post('/api/dashboard/articles/:id/restore', async (req, res) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ success: false, error: 'Not authenticated' });
      }
      
      const userId = req.user.id;
      const articleId = parseInt(req.params.id, 10);
      
      if (isNaN(articleId)) {
        return res.status(400).json({ success: false, error: 'Invalid article ID' });
      }
      
      const article = await storage.getArticleById(articleId);
      
      if (!article) {
        return res.status(404).json({ success: false, error: 'Article not found' });
      }
      
      // Kiểm tra quyền sở hữu bài viết
      if (article.userId !== userId && req.user.role !== 'admin') {
        return res.status(403).json({ success: false, error: 'You do not have permission to restore this article' });
      }
      
      // Kiểm tra trạng thái hiện tại
      if (article.status !== 'trash') {
        return res.status(400).json({ success: false, error: 'Article is not in trash' });
      }
      
      // Cập nhật trạng thái trở lại draft
      const restoredArticle = await storage.updateArticle(articleId, {
        status: 'draft',
        trashedAt: null
      });
      
      res.json({ success: true, data: restoredArticle });
    } catch (error) {
      console.error('Error restoring article:', error);
      res.status(500).json({ success: false, error: 'Failed to restore article' });
    }
  });

  // Get admin settings
  app.get('/api/admin/settings', async (req, res) => {
    try {
      if (!req.isAuthenticated() || req.user.role !== 'admin') {
        return res.status(403).json({ success: false, error: 'Admin access required' });
      }
      
      const generalSettings = await storage.getSettingsByCategory('general');
      const webhookSettings = await storage.getSettingsByCategory('webhook');
      const emailSettings = await storage.getSettingsByCategory('email');
      
      const settings = {
        general: generalSettings,
        webhook: webhookSettings,
        email: emailSettings
      };
      
      res.json({ success: true, data: settings });
    } catch (error) {
      console.error('Error fetching admin settings:', error);
      res.status(500).json({ success: false, error: 'Failed to fetch admin settings' });
    }
  });

  // Update general settings
  app.patch('/api/admin/settings/general', async (req, res) => {
    try {
      if (!req.isAuthenticated() || req.user.role !== 'admin') {
        return res.status(403).json({ success: false, error: 'Admin access required' });
      }
      
      const { 
        siteName, 
        siteDescription, 
        defaultLanguage,
        userRegistrationEnabled,
        publicApiEnabled,
        maxRequestsPerMinute,
        enabledFeatures = []
      } = req.body;
      
      // Update settings one by one
      const updates = [];
      
      if (siteName !== undefined) {
        updates.push(storage.setSetting('siteName', siteName, 'general'));
      }
      
      if (siteDescription !== undefined) {
        updates.push(storage.setSetting('siteDescription', siteDescription, 'general'));
      }
      
      if (defaultLanguage !== undefined) {
        updates.push(storage.setSetting('defaultLanguage', defaultLanguage, 'general'));
      }
      
      if (userRegistrationEnabled !== undefined) {
        updates.push(storage.setSetting(
          'userRegistrationEnabled', 
          userRegistrationEnabled ? 'true' : 'false', 
          'general'
        ));
      }
      
      if (publicApiEnabled !== undefined) {
        updates.push(storage.setSetting(
          'publicApiEnabled', 
          publicApiEnabled ? 'true' : 'false', 
          'general'
        ));
      }
      
      if (maxRequestsPerMinute !== undefined) {
        updates.push(storage.setSetting(
          'maxRequestsPerMinute', 
          maxRequestsPerMinute.toString(), 
          'general'
        ));
      }
      
      if (enabledFeatures.length > 0) {
        updates.push(storage.setSetting(
          'enabledFeatures', 
          JSON.stringify(enabledFeatures), 
          'general'
        )); 
      }
      
      await Promise.all(updates);
      
      // Get updated settings
      const updatedSettings = await storage.getSettingsByCategory('general');
      
      res.json({ success: true, data: updatedSettings });
    } catch (error) {
      console.error('Error updating general settings:', error);
      res.status(500).json({ success: false, error: 'Failed to update general settings' });
    }
  });

  // Update webhook settings
  app.patch('/api/admin/settings/webhook', async (req, res) => {
    try {
      if (!req.isAuthenticated() || req.user.role !== 'admin') {
        return res.status(403).json({ success: false, error: 'Admin access required' });
      }
      
      const { webhookSecret, notificationWebhookUrl } = req.body;
      
      // Update settings one by one
      const updates = [];
      
      if (webhookSecret !== undefined) {
        updates.push(storage.setSetting(
          'webhook_secret', 
          webhookSecret, 
          'webhook'
        ));
      }
      
      if (notificationWebhookUrl !== undefined) {
        updates.push(storage.setSetting(
          'notificationWebhookUrl', 
          notificationWebhookUrl, 
          'webhook'
        ));
      }
      
      await Promise.all(updates);
      
      // Get updated settings
      const updatedSettings = await storage.getSettingsByCategory('webhook');
      
      res.json({ success: true, data: updatedSettings });
    } catch (error) {
      console.error('Error updating webhook settings:', error);
      res.status(500).json({ success: false, error: 'Failed to update webhook settings' });
    }
  });

  // Get admin performance metrics
  app.get('/api/admin/performance', async (req, res) => {
    try {
      if (!req.isAuthenticated() || req.user.role !== 'admin') {
        return res.status(403).json({ success: false, error: 'Admin access required' });
      }
      
      // Dummy data for response time history
      const historyPoints = 30; // 30 days
      
      const responseTimeHistory = Array.from({ length: historyPoints }, (_, i) => {
        return {
          date: new Date(Date.now() - (historyPoints - i - 1) * 24 * 60 * 60 * 1000).toISOString().split('T')[0],
          avgResponseTime: Math.floor(100 + Math.random() * 200), // 100-300ms
          p90ResponseTime: Math.floor(250 + Math.random() * 350), // 250-600ms
          p99ResponseTime: Math.floor(500 + Math.random() * 1000), // 500-1500ms
        };
      });
      
      const requestsHistory = Array.from({ length: historyPoints }, (_, i) => {
        return {
          date: new Date(Date.now() - (historyPoints - i - 1) * 24 * 60 * 60 * 1000).toISOString().split('T')[0],
          totalRequests: Math.floor(1000 + Math.random() * 9000), // 1K-10K requests
          successfulRequests: Math.floor(900 + Math.random() * 8100), // 90% success rate approx
          errorRequests: Math.floor(100 + Math.random() * 900), // 10% error rate approx
        };
      });
      
      const resourceUsageHistory = Array.from({ length: historyPoints }, (_, i) => {
        return {
          date: new Date(Date.now() - (historyPoints - i - 1) * 24 * 60 * 60 * 1000).toISOString().split('T')[0],
          cpuUsage: Math.floor(10 + Math.random() * 70), // 10-80% CPU usage
          memoryUsage: Math.floor(20 + Math.random() * 60), // 20-80% Memory usage
          diskUsage: Math.floor(30 + Math.random() * 50), // 30-80% Disk usage
        };
      });
      
      // Top API endpoints by usage
      const topEndpoints = [
        { endpoint: "/api/articles", count: 5230, averageTime: 132, errorRate: 1.2 },
        { endpoint: "/api/user", count: 8450, averageTime: 88, errorRate: 0.8 },
        { endpoint: "/api/generate-content", count: 1820, averageTime: 2350, errorRate: 5.2 },
        { endpoint: "/api/admin/stats", count: 645, averageTime: 165, errorRate: 3.1 },
        { endpoint: "/api/plans", count: 1230, averageTime: 112, errorRate: 1.5 },
      ];
      
      // Current server stats
      const serverStats = {
        uptime: Math.floor(Math.random() * 30 * 24 * 60 * 60), // Up to 30 days in seconds
        currentConnections: Math.floor(10 + Math.random() * 90), // 10-100 connections
        peakConnections: Math.floor(50 + Math.random() * 950), // 50-1000 peak connections
        totalRequests: requestsHistory.reduce((sum, day) => sum + day.totalRequests, 0),
        averageResponseTime: Math.floor(
          responseTimeHistory.reduce((sum, day) => sum + day.avgResponseTime, 0) / historyPoints
        ),
      };
      
      res.json({
        success: true,
        data: {
          responseTimeHistory,
          requestsHistory,
          resourceUsageHistory,
          topEndpoints,
          serverStats,
        }
      });
    } catch (error) {
      console.error('Error fetching performance metrics:', error);
      res.status(500).json({ success: false, error: 'Failed to fetch performance metrics' });
    }
  });
  
  return httpServer;
}
